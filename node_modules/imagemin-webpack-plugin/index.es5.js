'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var optimizeImage = function () {
  var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(asset, imageminOptions) {
    var assetSource, assetOrigSize, assetContents, optimizedAssetContents;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // Grab the orig source and size
            assetSource = asset.source();
            assetOrigSize = asset.size();

            // Ensure that the contents i have are in the form of a buffer

            assetContents = Buffer.isBuffer(assetSource) ? assetSource : new Buffer(assetSource, 'utf8');

            // Await for imagemin to do the compression

            _context3.next = 5;
            return _imagemin2.default.buffer(assetContents, imageminOptions);

          case 5:
            optimizedAssetContents = _context3.sent;

            if (!(optimizedAssetContents.length < assetOrigSize)) {
              _context3.next = 10;
              break;
            }

            return _context3.abrupt('return', new _RawSource2.default(optimizedAssetContents));

          case 10:
            return _context3.abrupt('return', asset);

          case 11:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function optimizeImage(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

var _lodash = require('lodash.map');

var _lodash2 = _interopRequireDefault(_lodash);

var _RawSource = require('webpack-sources/lib/RawSource');

var _RawSource2 = _interopRequireDefault(_RawSource);

var _imagemin = require('imagemin');

var _imagemin2 = _interopRequireDefault(_imagemin);

var _imageminPngquant = require('imagemin-pngquant');

var _imageminPngquant2 = _interopRequireDefault(_imageminPngquant);

var _imageminOptipng = require('imagemin-optipng');

var _imageminOptipng2 = _interopRequireDefault(_imageminOptipng);

var _imageminGifsicle = require('imagemin-gifsicle');

var _imageminGifsicle2 = _interopRequireDefault(_imageminGifsicle);

var _imageminJpegtran = require('imagemin-jpegtran');

var _imageminJpegtran2 = _interopRequireDefault(_imageminJpegtran);

var _imageminSvgo = require('imagemin-svgo');

var _imageminSvgo2 = _interopRequireDefault(_imageminSvgo);

var _os = require('os');

var _asyncThrottle = require('async-throttle');

var _asyncThrottle2 = _interopRequireDefault(_asyncThrottle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ImageminPlugin() {
  var _options$imageminOpti;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // I love ES2015!
  var _options$disable = options.disable;
  var disable = _options$disable === undefined ? false : _options$disable;
  var _options$optipng = options.optipng;
  var optipng = _options$optipng === undefined ? {
    optimizationLevel: 3
  } : _options$optipng;
  var _options$gifsicle = options.gifsicle;
  var gifsicle = _options$gifsicle === undefined ? {
    optimizationLevel: 1
  } : _options$gifsicle;
  var _options$jpegtran = options.jpegtran;
  var jpegtran = _options$jpegtran === undefined ? {
    progressive: false
  } : _options$jpegtran;
  var _options$svgo = options.svgo;
  var svgo = _options$svgo === undefined ? {} : _options$svgo;
  var _options$pngquant = options.pngquant;
  var pngquant = _options$pngquant === undefined ? null : _options$pngquant;
  var _options$maxConcurren = options.maxConcurrency;
  var maxConcurrency = _options$maxConcurren === undefined ? (0, _os.cpus)().length : _options$maxConcurren;
  var _options$plugins = options.plugins;
  var plugins = _options$plugins === undefined ? [] : _options$plugins;


  this.options = {
    disable: disable,
    maxConcurrency: maxConcurrency,
    imageminOptions: {
      plugins: []
    }
  };

  // As long as the options aren't `null` then include the plugin. Let the destructuring above
  // control whether the plugin is included by default or not.
  var _arr = [[_imageminOptipng2.default, optipng], [_imageminGifsicle2.default, gifsicle], [_imageminJpegtran2.default, jpegtran], [_imageminSvgo2.default, svgo], [_imageminPngquant2.default, pngquant]];
  for (var _i = 0; _i < _arr.length; _i++) {
    var _arr$_i = (0, _slicedToArray3.default)(_arr[_i], 2);

    var plugin = _arr$_i[0];
    var pluginOptions = _arr$_i[1];

    if (pluginOptions !== null) {
      this.options.imageminOptions.plugins.push(plugin(pluginOptions));
    }
  }

  // And finally, add any plugins that they pass in the options to the internal plugins array
  (_options$imageminOpti = this.options.imageminOptions.plugins).push.apply(_options$imageminOpti, (0, _toConsumableArray3.default)(plugins));
}

ImageminPlugin.prototype.apply = function (compiler) {
  var _this = this;

  // If disabled, short-circuit here and just return
  if (this.options.disable === true) return null;

  // Access the assets once they have been assembled
  compiler.plugin('emit', function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(compilation, callback) {
      var throttle;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              throttle = (0, _asyncThrottle2.default)(_this.options.maxConcurrency);
              _context2.prev = 1;
              _context2.next = 4;
              return _promise2.default.all((0, _lodash2.default)(compilation.assets, function (asset, filename) {
                return throttle((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return optimizeImage(asset, _this.options.imageminOptions);

                        case 2:
                          compilation.assets[filename] = _context.sent;

                        case 3:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _callee, _this);
                })));
              }));

            case 4:

              // At this point everything is done, so call the callback without anything in it
              callback();
              _context2.next = 10;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2['catch'](1);

              callback(_context2.t0);

            case 10:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, _this, [[1, 7]]);
    }));

    return function (_x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }());
};

exports.default = ImageminPlugin;
